# COMPENDIUM EXAMPLE

## Testing on local device

**Required:**

1. **postgres or docker**: compendium requires a postgres database to save schemas. If you didn't install on your machine a postgres database, you can use our docker file in the [compendium project](https://github.com/higherkindness/compendium).

2. **postman or similar**: in order to add new schemas in our compendium server (ie. postgres database), we'll have to make some http requests.

3. **a working `compendium server`**: check our [compendium project](https://github.com/higherkindness/compendium)!

**Set up configuration:**

- **Postgres in local.**

    By default: pointing to `localhost:5432` and database `postgres`.
 Configurable on environment var: `COMPENDIUM_METADATA_STORAGE_JDBC_URL` by default: `"jdbc:postgresql://localhost:5432/postgres"`

- **Docker**

  In the root directory of [compendium project](https://github.com/higherkindness/compendium) you can find a `docker-compose` yaml file and a `Dockerfile` file. On that directory, run

        docker-compose up

- **Postman**

    Import collection on `postman/compendium.postman_collection.json`. Please notice this has `localhost:8080` as a default host for compendium server.
    POST calls has to give a **string** with the whole schema. It wil be parsed internally.

    Currently `sbt-compendium` handles avro schema. But `compendium-server` admits `protobuf`, `mu`, `scala`, `avro` and `openapi`.

- **sbt plugin**

    Add to your `project/plugin.sbt` file the following line

    `addSbtPlugin("io.higherkindness" %% "sbt-compendium" % "0.0.1-SNAPSHOT")`

    Also to your `build.sbt` file add to your project settings

    `.settings(
         compendiumSrcGenProtocolIdentifiers := List(ProtocolAndVersion("supplier",None),ProtocolAndVersion("material",None),ProtocolAndVersion("sale",None)),
         compendiumSrcGenServerHost := "localhost",
         compendiumSrcGenServerPort := 8080,
         sourceGenerators in Compile += Def.task {
           compendiumSrcGenClients.value
         }.taskValue
    )`

    The configuration works as follow:

    - `compendiumSrcGenServerHost`: case class ProtocolAndVersion(name: String, version: Option[String]). Url of the compendium server. Default: "localhost"
    - `compendiumSrcGenServerPort`: Integer. Port of the compendium server. Default: 47047
    - `compendiumSrcGenFormatSchema`: IdlName type. Schema type to download. Default: IdlName.Avro. Valid values: Avro, Proto, OpenApi, Mu, Scala.
    - `compendiumSrcGenProtocolIdentifiers: `List[String]`. Protocol identifiers to be retrieved from compendium server. Default: Nil


## [Avro] Model example
To show this example run:

    sbt "project avroExample" run

- The log traces will show some data.
- In `target/scala-2.12/src_managed` will appear scala files with all the case classes.
- On `plugin/src/main/resources` there are some csv files with data that correspond to its proper case class.


Let's suppose some data with the following structure:

| name | fields |
| ---- | ------ |
| supplier | id_supplier, name, email, phone |
| sale | client*, product** |
| client* | id_client, name, surname, email |
| product** | id_prod, description, color, size |
| material | name, code, shipId |


In postgres, schemas will be saved as a full string with the POST call:

| name | schema |
| ------- | ---------------------------------------- |
| supplier | "{\"type\":\"record\",\"name\":\"Supplier\",\"namespace\":\"higherkindness.compendiumtest\",\"fields\":[{\"name\":\"id_supplier\",\"type\":\"string\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"email\",\"type\":\"string\"},{\"name\":\"phone\",\"type\":\"string\"}]}" |
| sale | "{\"type\":\"record\",\"name\":\"Sale\",\"namespace\":\"higherkindness.compendiumtest\",\"fields\":[{\"name\":\"client\",\"type\":{\"type\":\"record\",\"name\":\"Client\",\"fields\":[{\"name\":\"id_client\",\"type\":\"string\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"surname\",\"type\":\"string\"},{\"name\":\"email\",\"type\":\"string\"}]}},{\"name\":\"product\",\"type\":{\"type\":\"record\",\"name\":\"Product\",\"fields\":[{\"name\":\"id_prod\",\"type\":\"string\"},{\"name\":\"description\",\"type\":\"string\"},{\"name\":\"color\",\"type\":\"string\"},{\"name\":\"size\",\"type\":\"string\"}]}}]}" |
| client* | Generated by the nested schema in `sale` |
| product** | Generated by the nested schema in `sale` |
| material | "{\"type\":\"record\",\"name\":\"Material\",\"namespace\":\"higherkindness.compendiumtest\",\"fields\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"code\",\"type\":\"string\"},{\"name\":\"shipId\",\"type\":\"string\"}]}" |

- Schemas have been flatted using [From json to string Converter](https://tools.knowledgewalls.com/jsontostring)
- Data has been generated using [Mockaroo](https://mockaroo.com/).

Please, notice that in POST calls the identifiers need to be added to the `compendiumProtocolIdentifiers` list in the `build.sbt` file.


### Avro files in JSON format

This section provides, in json format, the schemas presented previously. Also it contains new models and versions to test the behaviour of `compendium`.
Remember, compendium always provides the last version saved unless otherwise stated.

##### Supplier schema:

    {
      "type": "record",
      "name": "Supplier",
      "namespace": "higherkindness.compendiumtest",
      "fields": [
        {
            "name": "id_supplier",
            "type": "string"
        }, 
        {
            "name": "name",
            "type": "string"
        },
        {
            "name": "email",
            "type": "string"
        },
        {
            "name": "phone",
            "type": "string"
        }
      ]
    }

##### Sale schema:

    {
      "type": "record",
      "name": "Sale",
      "namespace": "higherkindness.compendiumtest",
      "fields": [
        {
            "name": "client",
            "type": "higherkindness.compendiumtest.Client"
        },
        {
            "name": "product",
            "type": "higherkindness.compendiumtest.Product"
        }
      ]
    }

##### Client schema [used in nested supplier schema]:

    {
      "type": "record",
      "name": "Client",
      "namespace": "higherkindness.compendiumtest",
      "fields": [
        {
            "name": "id_client",
            "type": "string"
        },  
        {
            "name": "name",
            "type": "string"
        },
        {
            "name": "surname",
            "type": "string"
        },
        {
            "name": "email",
            "type": "string"
        }
      ]
    }


##### Product schema [used in nested Supplier schema]:

    {
      "type": "record",
      "name": "Product",
      "namespace": "higherkindness.compendiumtest",
      "fields": [
        {
            "name": "id_prod",
            "type": "string"
        },
        {
            "name": "description",
            "type": "string"
        },    
        {
            "name": "color",
            "type": "string"
        },
        {
            "name": "size",
            "type": "string"
        }
      ]
    }

##### Material schema (first version):

    {
      "type": "record",
      "name": "Material",
      "namespace": "higherkindness.compendiumtest",
      "fields": [
        {
            "name": "name",
            "type": "string"
        },
        {
            "name": "code",
            "type": "string"
        },
        {
            "name": "shipId",
            "type": "string"
        }
      ]
    }


#### Future iterations

##### Product schema (second version):

    {
      "type": "record",
      "name": "Product",
      "namespace": "higherkindness.compendiumtest",
      "fields": [
         {
            "name": "id_prod",
            "type": "string"
        },
        {
            "name": "name",
            "type": "string"
        },
        {
            "name": "color",
            "type": "string"
        },
        {
            "name": "size",
            "type": "string"
        },
        {
            "name": "soldDate",
            "type": "string"
        }
      ]
    }


##### Material schema (second version):

    {
      "type": "record",
      "name": "Material",
      "namespace": "higherkindness.compendiumtest",
      "fields": [
        {
            "name": "name",
            "type": "string"
        },
        {
            "name": "code",
            "type": "string"
        },
        {
            "name": "originIdentifier",
            "type": "higherkindness.compendiumtest.Supplier"
        },    
        {
            "name": "shipId",
            "type": "string"
        },    
        {
            "name": "color",
            "type": "string"
        }
      ]
    }

##### Process version:

    {
      "type": "record",
      "name": "Process",
      "namespace": "higherkindness.compendiumtest",
      "fields": [
        {
            "name": "name",
            "type": "string"
        },
        {
            "name": "mat",
            "type": {
                "type": "array",
                "items": "higherkindness.compendiumtest.Material"
            }
        },
        {
            "name": "prod",
            "type": "higherkindness.compendiumtest.Product"
        }
      ]
    }

## [Proto] Model example

The following dependency is *mandatory* for protobuf type:

     "com.47deg"    %% "pbdirect" % "0.4.1"

To show this example run:

    sbt "project protoExample" run

- The log traces will show some data.
- In `target/scala-2.12/src_managed` will appear scala files with all the case classes.
- In this case, each class will be created inside a `compendium` package object. To access to a certain class you'll need to import `import [actually.your.package].compendium`

### Structure

Let's suppose some data with the following structure:

| name | fields |
| ---- | ------ |
| supplier | id_supplier, name, email, phone |
| sale | client*, product** |
| client* | id_client, name, surname, email |
| product** | id_prod, description, color, size |
| material | name, code, shipId |


In postgres, schemas will be saved as a full string with the POST call:

    "syntax = \"proto3\";\n\npackage higherkindness.compendiumtest;\n\nmessage Supplier {\n  string id_supplier = 1;\n  string name = 2;\n  string email = 3;\n  string phone = 4;\n}\n\nmessage Client {\n  string id_client = 1;\n  string name = 2;\n  string surname = 3;\n  string email = 4;\n}\n\nmessage Product {\n  string id_prod = 1;\n  string description = 2;\n  string color = 3;\n  string size = 4;\n}\n\nmessage Sale {\n Client client = 1;\n Product product = 2;\n}\n\n\nservice SearchOps {\n  rpc FindProducts (Client) returns (Product);\n  rpc FindClients (Product) returns (Client);\n}"

### Full schema

    syntax = "proto3";
    
    package higherkindness.compendiumtest;
    
    message Supplier {
      string id_supplier = 1;
      string name = 2;
      string email = 3;
      string phone = 4;
    }
    
    message Client {
      string id_client = 1;
      string name = 2;
      string surname = 3;
      string email = 4;
    }
    
    message Product {
      string id_prod = 1;
      string description = 2;
      string color = 3;
      string size = 4;
    }
    
    message Sale {
      Client client = 1;
      Product product = 2;
    }
    
    
    service SearchOps {
      rpc FindProducts (Client) returns (Product);
      rpc FindClients (Product) returns (Client);
    }